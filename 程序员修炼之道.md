# 						《程序员修炼之道》 

# 			《The Pragmatic Programmer》

​																															作者：Andy Hunt 、 Dave Thomas 

​				两位作者除了是程序员，Andy Hunt还是一位木匠和音乐家，而Dave Thomas 则喜欢驾驶单引擎飞机。

<font size = 2> -------你不该局限于特定的技术，而应拥有足够广博的背景和经验基础，以让你能在特定情况下选择好的解决方案。你的背景源于对计算机科学的基本原理的理解，而你的经验来自广泛的实践项目，理论与实践的结合将使你强大起来。</font>

## 注重时效的哲学

- 我的源码让猫吃了          *在所有弱点中，最大的弱点就是害怕暴露弱点。*

  ​		<b> 负责</b>       依据你的职业发展、你的发展很你每天的工作、为你自己和你的行为负责这样一种观念，是注重时效的哲学的一块基石。为自己的职业生涯负责，并且不害怕承认无知与错误，这肯定不是编程让人愉悦的方面，但他肯定会发生。在发生未曾预见的技术问题时，我们要设法职业地处理他们，这意味着诚实与坦率。我们可以为我们的能力自豪，但对于我们的缺点------还有我们的无知与错误------我们必须诚实。

- 软件的熵                       *Don`t Live with Broken Windows*

  ​		<b> 不留破窗</b>     开发几乎不受物理定律的约束。熵表示一个系统中“无序”的总量，遗憾的是，热力学定律保证了宇宙的熵倾向于最大化，当软件无序增长时称之为“程序腐烂”[^software rot]。有许多因素促使着这发生，即使有着极佳的规划与团队，在项目的生命周期中也可能遭遇毁灭；而有的团队成功击败自然的无需倾向设法得到好的结果。文中通过破窗效应以及消防员救火却不愿弄脏地毯的故事来说明：当团队和项目代码十分漂亮时，你就可能会格外 注意不去弄脏它，就和消防员一样，即使有火在咆哮谁也不愿成为第一个弄脏东西的人。

- 足够好的软件             *欲求更好，常把好事变遭。*

   		<b>足够好</b>		现实世界不会让我们制作出十分完美的产品，特别是无错的产品，时间、技术和急躁都在合谋对抗我们。足够好的代码是否需要继续提升？所有系统都必须满足其用户的需求才能成功。应该给用户机会让他们参与决定你所制作的东西何时已足够好。不同的项目背景下，对项目有着不同的要求。一个项目的事实需要多个部门的协同，每个部门间都有其需要完成及保证的事情。不顾其他而不断为程序添加新特性亦或是一次又一次的 润饰代码绝非职业做法。使质量成为需求问题，知道何时止步。

- 你的知识资产      *知识上的投资总能得到最好的回报*

  - 经营资产
    - 定期投资 
    - 多元化      做好调整，赶上变化
    - 管理风险  不要把技术都放在一个篮子里
    - 低卖高卖 

  - 目标
    - 每年至少学习一门新语言
    - 每季度至少阅读一本技术书籍
    - 非技术书籍同样重要
    - 上课
    - 参加本地组织，参与其中
    - 实验不同的环境
    - 跟上潮流
    - 上网冲浪
    - 。。。。。。

  ```
  	与古鲁交流的
  ```

  

  

## 注重时效的途径

- 重复		*DRY*  --Don`t repeat yourself.

  ​		重复产生的原因大致可划分为：环境使得开发者无法选择、构思不准确而引起的无意间的重复、偷懒式的重复、开发者间由于沟通不足引起的重复。应避免不必要的重复，使得系统整体不会臃肿，维护相对简单。

- 正交性

  保持系统的正交性也称内聚。组件间相互隔离时，在修改一个组件时就可以不用担心影响到其他组件，只要不影响对外接口便可以不波及整个系统。由此正交性在提高生产率时也推动着风险的降低。大多数开发中熟知需要设计这类系统，分层间的模块使得系统拥有灵活性。对于设计的正交模型进行简单自测：如果显著修改摸个特定功能背后的需求后有多少模块会受到影响？理想答案当然是一个，应该尽量接近。

  思考的问题：编写一个Split的类，用途为将输入行拆分为字段，比较两个类的设计，那个更为正交？

  > ```java
  > Class Split1{
  > public Split1(InputStreamReader rdr){...}
  > public void readNextLine() throws IOException {...}
  > public int numberFields(){...}
  > public String getField(int fieldNo){...}
  > }
  > 
  > Class Split2{
  > public Split2(String line){...}
  > public  int numberFields(){...}
  > public String getField(int fieldNo){...}
  > }
  > ```
  >

     	我第一反应是对比了两者有哪些函数，区别在构造函数处传入数据的来源不同；使用Split2类的话需要将不同来源的数据转化为String然后使用，而Split1类虽然多了一个读取的函数，看起来功能比较齐全，然而Split1将数据来源缩小了范围只对应于输入流的处理。也正是因为Split2将数据准备留给了外部，使得Split2更为灵活。

- 可撤销性        不存在最终决策

  ​		在一些关键决策后，目标会变小，使得稍微一点变动就能产生一连串反应。灵活的架构可以让我们较为 从容地面临改动。 

## 基本工具

- 纯文本的威力

     	存文本保存数据与压缩二进制相比存储空间更大，解释和处理存文本文件以及计算时的代价也更昂贵。然而存文本使得数据因其自身的易读性使得数据可以不过时，更易于在不同模式下的迁移，也更易于测试。

- shell游戏

    	  GUI 及 IDE 下使用鼠标即可完成写事情，不用不记忆繁琐的shell 命令。然而在GUI环境通常受限于设计者想要提供的能力，如果需要的能力超过设计者提供的，一些简单命令可以让处理速度更高效。

- 强力编辑

  ​		用好一种编辑器将带动许多。减少点击次数提升生产率也将提高体验。

- 调试        修正问题而不是发出指责

  ​		与报告BUG的用户交流可以收集更多的数据，人工合成的测试不能足够地演练应用。强烈冲击边界条件以及最终用户的使用模式，将使得系统更加完善。通过将运行数据可视化加可以更加深入地探寻系统运行的过程，加快揪出BUG的进程。解决掉眼前出现的BUG并不意味着任务的结束，要考虑代码中是否有哪些地方容易受这一部分影响，是否可以经过处理让同样的问题出现时更容易处理。

##  注重时效的偏执                  --你不可能写出完美的代码

- 按合约设计   Design by Contract (DbC)

  通过文档记载并约定软件模块的权利与责任，以确保程序的正确性 。

  书中对系统内函数或方法的期望与描述：

  - 前条件 ：为调用例程，必须为真的条件即例程的需求，传好数据是调用者的责任
  - 后条件：例程保证会完成的事情，例程完成时整体应该处于的状态
  - 类不变项：类确保从调用者的角度来看，不能给出无限制的对参与不变项的数据成员的写访问     

  对于一个方法的契约通常包含下面这些信息：

​		1.可接受和不可接受的值或类型，以及它们的含义

​		2.返回的值或类型，以及它们的含义

​		3.可能出现的错误以及异常情况的值和类型，以及它们的含义

​		4.副作用

​		5.先验条件

​		6.后验条件

​		7.不变式

​		8.(不太常见) 性能上的保证，如所用的时间和空间

继承中的子类型可以弱化先验条件（但不可以加强它们），并且可以加强后验条件和不变式（但不能弱化它们）。DbC促使需求与保证的问题走到前台，在设计时简单地列举输入域的范围、边界条件、例程职责与权限避免了靠巧合编程。将对前条件的检查留在调用者，在检查出参数问题时确保参数不会传到例程中，可以尽早处理 （报错或者其他操作）。由此便可以在输入有效的前提下，安全地设计例程。

> ```
> sqrt: Double is
> 	-- 	Square root routine
> 	require
> 		sqrt_arg_must_be_positive:Current >= 0;
> 	---...
> 	---calculate square root here
> 	---...
> 	ensure
> 	((Result* Result)->Current).abs <= epsilon* Current.abs;
> 		--Result should be  within error tolerance
> 	end;
> 	
> ```

- 死程序不说谎

  ​		我们很容易掉入“它不可能发生”这样的一种心理状态，所有的错误都能为你提供信息，你可以让自己相信错误不会发生，并选择忽略它。但预想情况下不应发生的问题出现就说明糟糕的事情发生了。防卫性的编程使得我们在程序的其他部分去查找那“调皮的小东西”，在别的地方搜寻他的踪迹，但结果是显而易见的。

  ​		早奔溃    尽早检测问题可以让我们在问题出现时尽早的处理。许多时候让程序直接奔溃是最佳选择，防止问题出现后引起一连串反应或者它会破坏掉某个重要文档亦或重要信息。而有时简单地退出运行中程序并不合适，可能我们申请的资源还没释放或许要写出日志。如何使用异常？

- 断言式编码       如果它不可能发生，用断言确保它不会发生。

     	编码时不可以自我欺骗，使用断言确保这“不可能发生的事情”。在大多数C及C++实现中，我们能找到某种形式的检查布尔条件的assert或_aseert宏，如传入指针不可为空可以：

  ```c
  void writeString(char* string){
  	assert(string != NULL);
  	...
  ```

  断言在编译时可能会被关闭，不可将必须执行的代码放在assert中，也不能用它替代真正的错误处理。断言使用时要避免副作用，书中简例:

  ```java
  while(iter.hasMoreElements()){
      Test.ASSERT(iter.nextElements() != null);
      Object obj = jter.nextElement()；
          ...
  }
  ```

  在断言处调用的函数使得循环只能处理集合中的一半元素，更好的处理：

  ```
  while(iter.hasMoreElements()){
      Object obj = iter.nextElement()；
      Test.ASSERT(obj != null);
          ...
  }
  ```

  在对运行速度有要求的部分让断言成为可调的，如在C中通过预编译器或if语句实现。

- 如何使用异常

  何时 使用异常情况我们只能说取决于具体情况。如果试图对一个文件进行读取，而文件并不存在，应该引发异常吗？

- 怎样配平资源

## 弯曲，或折断

- 解耦与德墨忒尔法则[^亦称为“最少知识原则（Principle of Least Knowledge）”]

- 元程序设计
- 时间耦合
- 它只是视图
- 黑板

## 当你编码时

- 靠巧合编程
- 算法速率
- 重构
- 易于测试的代码
- 邪恶的向导

## 在项目开始之前

- 需求之坑
- 解开不可能解开的谜题
- 等你准备好
- 规范陷阱
- 圆圈与箭头

## 注重时效的项目

- 注重时效的团队
- 无处不在的自动化
- 无情的测试 
- 全都是写
- 极大的期望
- 傲慢与偏见 

---------

<font size = 3>注重时效的程序员之快速指南</font>